{
    "docs": [
        {
            "location": "/",
            "text": "Cubex User Interface Tutorial\n\n\nIn this set of tutorials, we will look at creating a full featured User Interface using React and MobX.  This is designed for someone with some prior knowledge of programming, but not necessarily UI frameworks or JavaScript/TypeScript.",
            "title": "Home"
        },
        {
            "location": "/#cubex-user-interface-tutorial",
            "text": "In this set of tutorials, we will look at creating a full featured User Interface using React and MobX.  This is designed for someone with some prior knowledge of programming, but not necessarily UI frameworks or JavaScript/TypeScript.",
            "title": "Cubex User Interface Tutorial"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/",
            "text": "Setting up your development environment can be done in just a few steps.\n\n\nInstalling TypeScript\n\n\nFor simplicity in these tutorials, you can download a boilerplate at \nhttps://github.com/sjohnsonaz/ts-boilerplate\n.  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.\n\n\nUsing npm\n\n\nFor TypeScript, the simplest way to install packages is through npm.  Any project using npm must define a \npackage.json\n file in its root directory.  The boilerplate above already has done this for you.  This file defines useful information about your project.  For simply developing a project, the most important sections are for defining its dependencies. However, if you were to publish your project to npm so others could use it, this file includes other important information which would need customizing.\n\n\nThe \npackage.json\n file defines several properties to store dependencies:\n\n\n\n\n\"dependencies\"\n\n\n\"devDependencies\"\n\n\n\"peerDependencies\"\n\n\n\"bundledDependencies\"\n\n\n\"optionalDependencies\"\n\n\n\n\nFor our purposes, we will be most concerned with the first two.  By default, packages are installed as \"dependencies\", which means any time your project is installed, these will be installed along with it.  However, in some cases your project may need certain packages while it is being developed, but not while it is being used.  For example, we might install TypeScript on the development environment to build our project, but we certainly don't need to deploy it along with the project.  In this case, these packages should be installed as \"devDependencies\".\n\n\nFor more information, refer to \npackage.json | npm Documentation\n.\n\n\nInstalling React and MobX\n\n\nWe need to install four packages as regular dependencies.\n\n\n\n\nreact\n\n\nreact-dom\n\n\nmobx\n\n\nmobx-react\n\n\n\n\nThis is done with a simple \nnpm install\n command:\n\n\nnpm install react react-dom mobx mobx-react\n\n\n\nIn older versions of npm, we would need to append \n--save\n to the end of that command.\n\n\nNext, we need to install several packages as \"devDependencies\".\n\n\n\n\n@types/react\n\n\n@types/react-dom\n\n\n\n\nThis provides the TypeScript typings to \nreact\n and \nreact-dom\n, which are only pure JavaScript packages.  Many pure JavaScript packages have related typings available, simply look for packages prefixed with \n@types\n.  However, these typings may be maintained separately from the orignal project, so some caution is advised.\n\n\nIn order to save these as \"devDependencies\", run:\n\n\nnpm install @types/react @types/react-dom --save-dev\n\n\n\nKeep in mind, any dependency to be saved to \"devDependencies\" should be installed with \n--save-dev\n appended.",
            "title": "Getting Started"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#installing-typescript",
            "text": "For simplicity in these tutorials, you can download a boilerplate at  https://github.com/sjohnsonaz/ts-boilerplate .  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.",
            "title": "Installing TypeScript"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#using-npm",
            "text": "For TypeScript, the simplest way to install packages is through npm.  Any project using npm must define a  package.json  file in its root directory.  The boilerplate above already has done this for you.  This file defines useful information about your project.  For simply developing a project, the most important sections are for defining its dependencies. However, if you were to publish your project to npm so others could use it, this file includes other important information which would need customizing.  The  package.json  file defines several properties to store dependencies:   \"dependencies\"  \"devDependencies\"  \"peerDependencies\"  \"bundledDependencies\"  \"optionalDependencies\"   For our purposes, we will be most concerned with the first two.  By default, packages are installed as \"dependencies\", which means any time your project is installed, these will be installed along with it.  However, in some cases your project may need certain packages while it is being developed, but not while it is being used.  For example, we might install TypeScript on the development environment to build our project, but we certainly don't need to deploy it along with the project.  In this case, these packages should be installed as \"devDependencies\".  For more information, refer to  package.json | npm Documentation .",
            "title": "Using npm"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#installing-react-and-mobx",
            "text": "We need to install four packages as regular dependencies.   react  react-dom  mobx  mobx-react   This is done with a simple  npm install  command:  npm install react react-dom mobx mobx-react  In older versions of npm, we would need to append  --save  to the end of that command.  Next, we need to install several packages as \"devDependencies\".   @types/react  @types/react-dom   This provides the TypeScript typings to  react  and  react-dom , which are only pure JavaScript packages.  Many pure JavaScript packages have related typings available, simply look for packages prefixed with  @types .  However, these typings may be maintained separately from the orignal project, so some caution is advised.  In order to save these as \"devDependencies\", run:  npm install @types/react @types/react-dom --save-dev  Keep in mind, any dependency to be saved to \"devDependencies\" should be installed with  --save-dev  appended.",
            "title": "Installing React and MobX"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/",
            "text": "In this tutorial, we take a look at React and MobX, what they can do, and the fundamental parts of any React and MobX project.  You should already have a TypeScript environment running, and have included the necessary packages in your project dependencies.\n\n\nProject Organization\n\n\nAny React and MobX project includes \nApplication State\n and \nComponents\n.  This is similar to many common patterns such as \nMVC\n or \nMVVM\n, where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.\n\n\nBefore we get started, your TypeScript project should have a \ntsconfig.json\n file.  Open this file, and ensure the following options are set:\n\n\n\"jsx\": \"react\",\n\"experimentalDecorators\": true,\n\"lib\": [\n    \"dom\",\n    \"es6\"\n]\n\n\n\n\nAlso, ensure that you have \nsrc\n and \npublic\n directories in your project.\n\n\nBuilding your Project\n\n\nIt will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.\n\n\nInside the \npublic\n directory, create a file \nindex.html\n.  This will be the main HTML file that runs the project.\n\n\n<!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"../../dist/bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>\n\n\n\n\nThis file creates a \n<div>\n to mount our component, and then loads the script.  Note that we're loading our script from \nbundle/main.js\n, which is a file that doesn't currently exist.  We are going to build it later.\n\n\nInside the \nsrc/scripts\n directory, create a file \nmain.tsx\n.\n\n\nwindow.onload = function () {\n    console.log('started');\n}\n\n\n\n\nWe now must set up Webpack to build our \nmain.tsx\n file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the \nentry\n and \noutput\n objects have the correct values.  it should read:\n\n\n    entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },\n\n\n\n\nThis is likely very similar to what is already there.  Simply change \nmain.ts\n to \nmain.tsx\n, the filename from \ndist\n to \npublic\n, and remove the \n.min\n portion of the filename.\n\n\nNow to test it, run\n\n\nnpm run dev\n\n\n\nIf you want to run automatically as you're developing, call\n\n\nnpm run watch\n\n\n\nIf you want to run a minified version of the file, call\n\n\nnpm run min\n\n\n\nIf it is successful, open the \npublic/index.html\n file in your browser.  Open the browser's console (F12 on Windows, Ctrl+Shift+J on Windows and Linux, or Cmd+Opt+J  on Mac), and you should see \nstarted\n printed to the screen.\n\n\nAlso, if you are using the ts-boilerplate code, clear the tests out of \ntest.ts\n.  This will prevent breaking any irrelevant tests.\n\n\nApplication State\n\n\nMobX stores its data in \nApplication State\n objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.  \n\n\nLet's say we want to create a \nModel\n of a \nUser\n.  It should store common information for our users, like first and last name.  We also will want to edit it.\n\n\nSo, we start by declaring a class, and adding several properties.  Inside your project, create a folder \nsrc/scripts/models\n, and inside it a file \nUser.ts\n.\n\n\nexport default class User {\n    firstName: string;\n    lastName: string;\n}\n\n\n\n\nFantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.\n\n\nComponents\n\n\nReact displays its data in \nComponents\n, which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.\n\n\nSo, since we have our User model, let's display it!  Inside your project, create a folder \nsrc/scripts/views\n, and inside it a file \nUserView.tsx\n.\n\n\nFirst, we must import React into the file.\n\n\nimport * as React from 'react';\n\n\n\n\nWe have imported React, which contains the Component class.  While we will not necessarily use the \nReact\n import directly in our code, the JSX interpreter will transpile our JSX statements into React calls.  This process turns what appear to be XML elements into:\n\n\nReact.createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P,\n        ...children: ReactNode[]): DOMElement<P, T>;\n\n\n\n\nNow we must import our User model.\n\n\nimport User from '../models/User';\n\n\n\n\nWe now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.\n\n\nexport interface IUserViewProps {\n    user: User;\n}\n\n\n\n\nNext we need to define our component itself.\n\n\nexport default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let { user } = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThis component takes in a user, and displays the \nfirstName\n and \nlastName\n inside to \n<p>\n elements, wrapped inside one \n<div>\n element.\n\n\nThere are a couple things to note:\n\n\n\n\nWe used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.\n\n\nWe used object destructuring to get \nuser\n from \nthis.props\n.  This is a shorthand that is much simpler than \nlet user = this.props.user;\n.  It especially comes in handy if you're doing that for multiple properties.\n\n\nEvery component must define a render method, even if it returns nothing.\n\n\nA component may return exactly one value.  Here we wrapped our multiple \n<p>\n tags in a single \n<div>\n tag.\n\n\nWe user the \n{}\n notation to insert the \nuser\n values into the elements.\n\n\n\n\nRendering\n\n\nWe now must render our \nApplication State\n into \nComponent\n and display it to the DOM.\n\n\nInside the \nmain.tsx\n we must import all of our files, and then render them.\n\n\nimport * as React from 'react';\nimport * as ReactDom from 'react-dom';\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    ReactDom.render(\n        <UserView user={user} />,\n        document.getElementById('root')\n    );\n};\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe imported ReactDom, our \nUser\n, and our \nUserView\n.\n\n\nWe write our code inside the onload function to ensure it runs after everything is ready.\n\n\nWe create a new user and set the first and last name properties.\n\n\nWe get the \nroot\n element from the DOM\n\n\nWe create a new \nUserView\n with JSX, pass in the user.\n\n\nWe pass the \nroot\n element and the \nUserView\n to \nReactDom.render()\n.\n\n\n\n\nNow build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Displaying Data"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#project-organization",
            "text": "Any React and MobX project includes  Application State  and  Components .  This is similar to many common patterns such as  MVC  or  MVVM , where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.  Before we get started, your TypeScript project should have a  tsconfig.json  file.  Open this file, and ensure the following options are set:  \"jsx\": \"react\",\n\"experimentalDecorators\": true,\n\"lib\": [\n    \"dom\",\n    \"es6\"\n]  Also, ensure that you have  src  and  public  directories in your project.",
            "title": "Project Organization"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#building-your-project",
            "text": "It will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.  Inside the  public  directory, create a file  index.html .  This will be the main HTML file that runs the project.  <!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"../../dist/bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>  This file creates a  <div>  to mount our component, and then loads the script.  Note that we're loading our script from  bundle/main.js , which is a file that doesn't currently exist.  We are going to build it later.  Inside the  src/scripts  directory, create a file  main.tsx .  window.onload = function () {\n    console.log('started');\n}  We now must set up Webpack to build our  main.tsx  file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the  entry  and  output  objects have the correct values.  it should read:      entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },  This is likely very similar to what is already there.  Simply change  main.ts  to  main.tsx , the filename from  dist  to  public , and remove the  .min  portion of the filename.  Now to test it, run  npm run dev  If you want to run automatically as you're developing, call  npm run watch  If you want to run a minified version of the file, call  npm run min  If it is successful, open the  public/index.html  file in your browser.  Open the browser's console (F12 on Windows, Ctrl+Shift+J on Windows and Linux, or Cmd+Opt+J  on Mac), and you should see  started  printed to the screen.  Also, if you are using the ts-boilerplate code, clear the tests out of  test.ts .  This will prevent breaking any irrelevant tests.",
            "title": "Building your Project"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#application-state",
            "text": "MobX stores its data in  Application State  objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.    Let's say we want to create a  Model  of a  User .  It should store common information for our users, like first and last name.  We also will want to edit it.  So, we start by declaring a class, and adding several properties.  Inside your project, create a folder  src/scripts/models , and inside it a file  User.ts .  export default class User {\n    firstName: string;\n    lastName: string;\n}  Fantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.",
            "title": "Application State"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#components",
            "text": "React displays its data in  Components , which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.  So, since we have our User model, let's display it!  Inside your project, create a folder  src/scripts/views , and inside it a file  UserView.tsx .  First, we must import React into the file.  import * as React from 'react';  We have imported React, which contains the Component class.  While we will not necessarily use the  React  import directly in our code, the JSX interpreter will transpile our JSX statements into React calls.  This process turns what appear to be XML elements into:  React.createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P,\n        ...children: ReactNode[]): DOMElement<P, T>;  Now we must import our User model.  import User from '../models/User';  We now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.  export interface IUserViewProps {\n    user: User;\n}  Next we need to define our component itself.  export default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let { user } = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}  This component takes in a user, and displays the  firstName  and  lastName  inside to  <p>  elements, wrapped inside one  <div>  element.  There are a couple things to note:   We used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.  We used object destructuring to get  user  from  this.props .  This is a shorthand that is much simpler than  let user = this.props.user; .  It especially comes in handy if you're doing that for multiple properties.  Every component must define a render method, even if it returns nothing.  A component may return exactly one value.  Here we wrapped our multiple  <p>  tags in a single  <div>  tag.  We user the  {}  notation to insert the  user  values into the elements.",
            "title": "Components"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#rendering",
            "text": "We now must render our  Application State  into  Component  and display it to the DOM.  Inside the  main.tsx  we must import all of our files, and then render them.  import * as React from 'react';\nimport * as ReactDom from 'react-dom';\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    ReactDom.render(\n        <UserView user={user} />,\n        document.getElementById('root')\n    );\n};  There are a couple things to note:   We imported ReactDom, our  User , and our  UserView .  We write our code inside the onload function to ensure it runs after everything is ready.  We create a new user and set the first and last name properties.  We get the  root  element from the DOM  We create a new  UserView  with JSX, pass in the user.  We pass the  root  element and the  UserView  to  ReactDom.render() .   Now build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Rendering"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/",
            "text": "We've successfully created a working Application.  When we run it, data is presented to the browser as intended.  But what happens if we want to change the data?  Currently, if we change the model, nothing.  Lucky for you, React and MobX makes this simple.\n\n\nObservable Properties\n\n\nMobX provides \nObservable\n properties for objects.  Once established, these special properties may be \nsubscribed\n to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.\n\n\nWe can use the TypeScript decorator \n@observable\n in the class definition to make a property observable.\n\n\n@observable property: type = value;\n\n\n\n\nLet's take our \nUser\n example from the last chapter, and make it observable.  So, simply import the \n@observable\n decorator, and add it in front of any properties you want to observe.\n\n\nimport { observable } from 'mobx';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}\n\n\n\n\nAnd there we have it!  Our \nfirstName\n and \nlastName\n properties are now Observables!\n\n\nHandling Input\n\n\nNow that we can watch for changes in our data, let's set up some inputs!  \n\n\nimport * as React from 'react';\nimport { observer } from 'mobx-react';\n\nimport User from '../../models/User';\n\nexport interface IUserViewProps {\n    user: User;\n}\n\n@observer\nexport default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nWe have included \nobserver\n decorator from \nmobx-react\n.\n\n\nWe have used the \n@observer\n in front of our \nUserView\n to allow it to detect changes to Observables.\n\n\nWe have included two \n<input>\n tags.\n\n\nWe inject the value using \n{}\n notation.\n\n\n\n\nWhen you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.\n\n\nReact works with \none way data binding\n, meaning that changes to data flow from \nApplication State\n to \nComponents\n not the other way around.  This is to prevent \ncircular references\n, where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.\n\n\nSo, any changes to our \nUser\n will show up in our \nUserView\n, but changes to our \nUserView\n don't automatically go back to our \nUser\n.  In order for that to happen, we need to handle \nEvents\n.\n\n\nAn \nEvent\n is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.\n\n\nFor our \nUserView\n add these two methods above the \nrender\n method.\n\n\nupdateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nThese methods will handle the \nEvent\n, and store the value of the target into our \nUser\n.\n\n\nWe are using the \nArrow Function\n notation, as the \nthis\n value may be changed while executing.\n\n\n\n\nBut how do we hook these handlers up to our inputs?\n\n\n<p>First name: <input type=\"text\" value={user.firstName} onChange={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} onChange={this.updateLastName} /></p>\n\n\n\n\nAnd that's it!  Any time the user updates the text inputs, the \nEvent\n is triggered, and the \nUser\n is updated.\n\n\nWe could also use regular methods instead of Arrow Functions for \nupdateFirstName\n and \nupdateLastName\n.  In that case, when we inject them, we must use \nFunction.bind()\n.\n\n\n<p>First name: <input type=\"text\" value={user.firstName} onChange={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} onChange={this.updateLastName.bind(this)} /></p>\n\n\n\n\nIn many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method, \nFunction.bind(this, value)\n is useful.\n\n\nRunning our Application\n\n\nSo, we can now display and update our \nUser\n.  Try running it and see what happens!",
            "title": "Updating Data"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#observable-properties",
            "text": "MobX provides  Observable  properties for objects.  Once established, these special properties may be  subscribed  to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.  We can use the TypeScript decorator  @observable  in the class definition to make a property observable.  @observable property: type = value;  Let's take our  User  example from the last chapter, and make it observable.  So, simply import the  @observable  decorator, and add it in front of any properties you want to observe.  import { observable } from 'mobx';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}  And there we have it!  Our  firstName  and  lastName  properties are now Observables!",
            "title": "Observable Properties"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#handling-input",
            "text": "Now that we can watch for changes in our data, let's set up some inputs!    import * as React from 'react';\nimport { observer } from 'mobx-react';\n\nimport User from '../../models/User';\n\nexport interface IUserViewProps {\n    user: User;\n}\n\n@observer\nexport default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}  There are a couple of things to note:   We have included  observer  decorator from  mobx-react .  We have used the  @observer  in front of our  UserView  to allow it to detect changes to Observables.  We have included two  <input>  tags.  We inject the value using  {}  notation.   When you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.  React works with  one way data binding , meaning that changes to data flow from  Application State  to  Components  not the other way around.  This is to prevent  circular references , where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.  So, any changes to our  User  will show up in our  UserView , but changes to our  UserView  don't automatically go back to our  User .  In order for that to happen, we need to handle  Events .  An  Event  is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.  For our  UserView  add these two methods above the  render  method.  updateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}  There are a couple of things to note:   These methods will handle the  Event , and store the value of the target into our  User .  We are using the  Arrow Function  notation, as the  this  value may be changed while executing.   But how do we hook these handlers up to our inputs?  <p>First name: <input type=\"text\" value={user.firstName} onChange={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} onChange={this.updateLastName} /></p>  And that's it!  Any time the user updates the text inputs, the  Event  is triggered, and the  User  is updated.  We could also use regular methods instead of Arrow Functions for  updateFirstName  and  updateLastName .  In that case, when we inject them, we must use  Function.bind() .  <p>First name: <input type=\"text\" value={user.firstName} onChange={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} onChange={this.updateLastName.bind(this)} /></p>  In many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method,  Function.bind(this, value)  is useful.",
            "title": "Handling Input"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#running-our-application",
            "text": "So, we can now display and update our  User .  Try running it and see what happens!",
            "title": "Running our Application"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/",
            "text": "We've looked at creating \nObservable\n properties, which let us watch for changes in our \nApplication State\n.  But how do our \nComponents\n track those changes?\n\n\nIf you look at the \nUserView.render\n method, we simply read from our \nUser\n.  MobX tracked those changes for us automatically using \nComputed\n properties.  For our Components, this is done behind the scenes.  But we can use them in our Application State just as easily.\n\n\nComputed Properties\n\n\nMobX provides \nComputed\n properties for objects, which use a getter function to produce a value.  However, any \nObservable\n properties used in this function, will automatically produce subscriptions.\n\n\nFor simplicity, we can also use the \n@computed\n decorator, except in front of a getter function.\n\n\n@computed get property(): type {\n    return this.value;\n}\n\n\n\n\nFor our \nUser\n let's add a \nfullName\n \nComputed\n property.  Add this right under the \nfirstName\n and \nlastName\n properties.\n\n\n@computed get fullName() {\n    return this.firstName + ' ' + this.lastName;\n}\n\n\n\n\nThen in our \nUserView\n, let's add the line\n\n\n<p>Full name: {user.fullName}</p>\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe simply used the values in order to subscribe to them automatically.\n\n\nWe can use as many values as we want.\n\n\nWhatever we return from this method will be the value of the property.\n\n\n\n\nAvoid Circular References\n\n\nIn order for updates to flow, we must avoid any \"circular references\" or \"cycles\".  This means that as an update is occurring, it must not reach the same node more than once.\n\n\nFor example, let's say we have two \nComputed\n properties, A and B.  And let's say A references B, and B references A.  So if A is updated, then we must update B.  Similarly if B is updated, we must update A.  In which case updating A, will update B, which will update A, which will update B, and so on.\n\n\nSo it is important that these situations be avoided.\n\n\nResponding to updates\n\n\nIt is best to avoid writing to \nObservable\n properties inside of a \nComputed\n.  In most cases, a second \nComputed\n which references the first will be enough.\n\n\nIf you must write to an \nObservable\n or do other work, it is best to wrap it inside of a \nwindow.setTimeout()\n, or use:",
            "title": "Computed Properties"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#computed-properties",
            "text": "MobX provides  Computed  properties for objects, which use a getter function to produce a value.  However, any  Observable  properties used in this function, will automatically produce subscriptions.  For simplicity, we can also use the  @computed  decorator, except in front of a getter function.  @computed get property(): type {\n    return this.value;\n}  For our  User  let's add a  fullName   Computed  property.  Add this right under the  firstName  and  lastName  properties.  @computed get fullName() {\n    return this.firstName + ' ' + this.lastName;\n}  Then in our  UserView , let's add the line  <p>Full name: {user.fullName}</p>  There are a couple things to note:   We simply used the values in order to subscribe to them automatically.  We can use as many values as we want.  Whatever we return from this method will be the value of the property.",
            "title": "Computed Properties"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#avoid-circular-references",
            "text": "In order for updates to flow, we must avoid any \"circular references\" or \"cycles\".  This means that as an update is occurring, it must not reach the same node more than once.  For example, let's say we have two  Computed  properties, A and B.  And let's say A references B, and B references A.  So if A is updated, then we must update B.  Similarly if B is updated, we must update A.  In which case updating A, will update B, which will update A, which will update B, and so on.  So it is important that these situations be avoided.",
            "title": "Avoid Circular References"
        },
        {
            "location": "/0-Overview/0.3-Computed-Properties/#responding-to-updates",
            "text": "It is best to avoid writing to  Observable  properties inside of a  Computed .  In most cases, a second  Computed  which references the first will be enough.  If you must write to an  Observable  or do other work, it is best to wrap it inside of a  window.setTimeout() , or use:",
            "title": "Responding to updates"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/",
            "text": "The DOM has built-in support for \nEvent-Driven\n programming.  This means your application can sit around and wait for user input or other \nEvents\n.  Once an \nEvent\n has occurred, its information is sent to a function called an \nEventListener\n.\n\n\nWe saw an example of this during the last section for handling \nchange\n events from \n<input>\n elements.  \n\n\nEvent Listeners\n\n\nUsing classical JavaScript \nDOM Element Attributes\n\n\n/* Code */\nfunction handleClick() {\n    ...\n}\n\n/* View */\n<button onclick=\"handleClick()\" />\n\n\n\n\nUsing JSX to inject \nEventListeners\n.\n\n\n/* Code */\nclass ViewModel {\n    handleClick() {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick.bind(this)} />\n\n\n\n\nUsing TypeScript arrow methods to simplify syntax.\n\n\n/* Code */\nclass ViewModel {\n    handleClick = () => {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick} />\n\n\n\n\nAsynchronous Programming\n\n\nJavaScript can be written as \nasynchronous\n code, meaning it doesn't have to always run in order.  Most of the time this isn't the case, as instructions are executed one after another.\n\n\nEvent Propagation\n\n\nEvent.stopPropagation();\nEvent.preventDefault();",
            "title": "Handling Events"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/#event-listeners",
            "text": "Using classical JavaScript  DOM Element Attributes  /* Code */\nfunction handleClick() {\n    ...\n}\n\n/* View */\n<button onclick=\"handleClick()\" />  Using JSX to inject  EventListeners .  /* Code */\nclass ViewModel {\n    handleClick() {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick.bind(this)} />  Using TypeScript arrow methods to simplify syntax.  /* Code */\nclass ViewModel {\n    handleClick = () => {\n        ...\n    }\n}\n\n/* View */\n<button onclick={viewModel.handleClick} />",
            "title": "Event Listeners"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/#asynchronous-programming",
            "text": "JavaScript can be written as  asynchronous  code, meaning it doesn't have to always run in order.  Most of the time this isn't the case, as instructions are executed one after another.",
            "title": "Asynchronous Programming"
        },
        {
            "location": "/0-Overview/0.4-Handling-Events/#event-propagation",
            "text": "Event.stopPropagation();\nEvent.preventDefault();",
            "title": "Event Propagation"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/",
            "text": "JavaScript supports two basic data structures for storing information, Arrays and Hashes.  Let's look at how we might add an Array and a Hash to a View Model.\n\n\nArrays\n\n\nTypeScript arrays can be defined and initialized in two ways, with the \nArray<T>\n type, or \nT[]\n type.  Both of these are equivalent, but one or the other may be easier to write depending on the situation.\n\n\nSo, if we were to create an Array of \nstring\n elements, it would be.\n\n\nlet list: string[] = [];\n\n\n\n\nThis code simply creates an variable called \nlist\n, defined as an \nstring[]\n and initializes it to be an empty \nArray\n.  It is important to note that we have initialized this variable, otherwise it would equal \nundefined\n.\n\n\nNow that we have created an \nArray\n, we can access its values with a regular \nAssignment Operator\n.  We can read and write values with:\n\n\nlet value = list[0];\nlist[1] = 2;\n\n\n\n\nWe can also use any of the \nArray\n methods, such as \nArray.prototype.push(value: any): void;\n\n\nlist.push(3);\n\n\n\n\nHashes\n\n\nNext, we have JavaScript Hashes, which are actually just regular Objects.\n\n\nTypeScript Hashes can be defined as an \ninterface\n, which stores elements with either \nstring\n or \nnumber\n indexes.  JavaScript allows for mixing index types, but TypeScript requies it to be one or the other.\n\n\nExternal Links\n\n\nFor more information on Arrays, visit \nArray - JavaScript | MDN\n\n\nFor more information on Objects, visit \nObjects - JavaScript | MDN\n\n\nView Models\n\n\nWe may store Arrays and Hashes as properties on a View Model.  For example:\n\n\nclass ViewModel {\n    list = [];\n    map = {};\n}\n\n\n\n\nHowever, just like regular properties, changes to these properties will be ignored.  Again, if we add our decorators, we can subscribe to changes.\n\n\nclass ViewModel {\n    @observable list = [];\n    @observable map = {};\n}\n\n\n\n\nWe can also be more specific about what is stored in Arrays and Hashes.\n\n\nclass ViewModel {\n    @observable list: string[];\n    @observable map: {\n        [index: string]: string\n    };\n}",
            "title": "Arrays and Hashes"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#arrays",
            "text": "TypeScript arrays can be defined and initialized in two ways, with the  Array<T>  type, or  T[]  type.  Both of these are equivalent, but one or the other may be easier to write depending on the situation.  So, if we were to create an Array of  string  elements, it would be.  let list: string[] = [];  This code simply creates an variable called  list , defined as an  string[]  and initializes it to be an empty  Array .  It is important to note that we have initialized this variable, otherwise it would equal  undefined .  Now that we have created an  Array , we can access its values with a regular  Assignment Operator .  We can read and write values with:  let value = list[0];\nlist[1] = 2;  We can also use any of the  Array  methods, such as  Array.prototype.push(value: any): void;  list.push(3);",
            "title": "Arrays"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#hashes",
            "text": "Next, we have JavaScript Hashes, which are actually just regular Objects.  TypeScript Hashes can be defined as an  interface , which stores elements with either  string  or  number  indexes.  JavaScript allows for mixing index types, but TypeScript requies it to be one or the other.",
            "title": "Hashes"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#external-links",
            "text": "For more information on Arrays, visit  Array - JavaScript | MDN  For more information on Objects, visit  Objects - JavaScript | MDN",
            "title": "External Links"
        },
        {
            "location": "/0-Overview/0.5-Arrays-and-Hashes/#view-models",
            "text": "We may store Arrays and Hashes as properties on a View Model.  For example:  class ViewModel {\n    list = [];\n    map = {};\n}  However, just like regular properties, changes to these properties will be ignored.  Again, if we add our decorators, we can subscribe to changes.  class ViewModel {\n    @observable list = [];\n    @observable map = {};\n}  We can also be more specific about what is stored in Arrays and Hashes.  class ViewModel {\n    @observable list: string[];\n    @observable map: {\n        [index: string]: string\n    };\n}",
            "title": "View Models"
        },
        {
            "location": "/0-Overview/0.6-TypeScript/",
            "text": "We've been using TypeScript for a while now, and it should feel very familiar for most JavaScript developers.  In fact, TypeScript really is JavaScript, just with some extra validation and intellisense.\n\n\nTypes\n\n\nClasses\n\n\nInterfaces",
            "title": "TypeScript"
        },
        {
            "location": "/0-Overview/0.6-TypeScript/#types",
            "text": "",
            "title": "Types"
        },
        {
            "location": "/0-Overview/0.6-TypeScript/#classes",
            "text": "",
            "title": "Classes"
        },
        {
            "location": "/0-Overview/0.6-TypeScript/#interfaces",
            "text": "",
            "title": "Interfaces"
        },
        {
            "location": "/0-Overview/0.7-Asynchronous-Execution/",
            "text": "JavaScript and TypeScript support various \n\n\nCallbacks\n\n\nwindow.setTimeout(function () {\n\n}, 1000);\n\n\n\n\n$.ajax('/api/user' + id, {\n    method: 'GET',\n    success: function(user: IUser) {\n\n    },\n    error: function(reason: any) {\n\n    }\n});\n\n\n\n\nfunction getUser(id, success: (user: IUser) => void, error: (reason: any) => void)\n    $.ajax('/api/user' + id, {\n        method: 'GET',\n        success:success,\n        error: error\n    });\n}\n\n\n\n\nfunction editUserPhone(id: string, phoneNumber: string, success: (result: boolean) => void, error: (reason: any) => void) {\n    getUser(id, function (user) {\n        if (user && user.id) {\n            getPhone(user.id, function (phone) {\n                if (phone && phone.id) {\n                    phone.phoneNumber = phoneNumber;\n                    updatePhone(phone.id, phone, function (result: boolean) {\n                        if (result) {\n                            success(result);\n                        } else {\n                            error('Unable to update phone');\n                        }\n                    }, function (reason: any) {\n                        error(reason);\n                    });\n                } else {\n                    error('No phone found');\n                }\n            },\n            function (reason: any) {\n                error(reason);\n            });\n        } else {\n            error('No user found');\n        }\n    }, function (reason: any) {\n        error(reason);\n    });\n}\n\n\n\n\nPromises\n\n\nLet's take a look at the Promise style code.  Here, each asynchronous function returns a \nPromise\n object, instead of taking in callback parameters.  This Promise provides access to the result of \nexactly one\n execution of the nested function.  Callbacks that execute many times, such as \nwindow.setInterval\n, \nArray.prototype.forEach\n, \nArray.prototype.map\n, etc., are used different from Promises.\n\n\nfunction editUserPhone(id: string, phoneNumber: string) {\n    return getUser(id).then(function (user) {\n        if (!user || !user.id) {\n            throw 'No user found';\n        }\n\n        return getPhone(user.id).then(function (phone) {\n            if (!phone || !phone.id) {\n                throw 'No phone found';\n            }\n\n            phone.phoneNumber = phoneNumber;\n            return updatePhone(phone.id, phone).then(function (result: boolean) {\n                if (!result) {\n                    throw 'Unable to update phone';\n                }\n\n                return result;\n            });\n        });\n    });\n}\n\n\n\n\nAsync/Await\n\n\nLet's now take a look at the \nasync\n and \nawait\n symbols.  If we mark a function as \nasync\n, it implicitly returns a \nPromise\n object.  This return type can be autogenerated by TypeScript, so a function that returns a \nboolean\n is now \nPromise<boolean>\n.\n\n\nOnce we have marked it as \nasync\n, we gain access to the \nawait\n symbol.  We simply use \nawait\n before executing any function that returns a \nPromise\n.  Instead of having to write \n.then(function (result) { })\n, the result will be turned to the left of the statement.  We can now write \nlet result = await getValue();\n, and \nresult\n will be populated with the data return from the asynchronous call.\n\n\nasync function editUserPhone(id: string, phoneNumber: string) {\n    let user = await getUser(id);\n    if (!user || !user.id) {\n        throw 'No user found';\n    }\n\n    let phone = await getPhone(user.id);\n    if (!phone || !phone.id) {\n        throw 'No phone found';\n    }\n\n    phone.phoneNumber = phoneNumber;\n    let result = await updatePhone(phone.id, phone);\n    if (!result) {\n        throw 'Unable to update phone';\n    }\n\n    return result;\n}",
            "title": "Asynchronous Execution"
        },
        {
            "location": "/0-Overview/0.7-Asynchronous-Execution/#callbacks",
            "text": "window.setTimeout(function () {\n\n}, 1000);  $.ajax('/api/user' + id, {\n    method: 'GET',\n    success: function(user: IUser) {\n\n    },\n    error: function(reason: any) {\n\n    }\n});  function getUser(id, success: (user: IUser) => void, error: (reason: any) => void)\n    $.ajax('/api/user' + id, {\n        method: 'GET',\n        success:success,\n        error: error\n    });\n}  function editUserPhone(id: string, phoneNumber: string, success: (result: boolean) => void, error: (reason: any) => void) {\n    getUser(id, function (user) {\n        if (user && user.id) {\n            getPhone(user.id, function (phone) {\n                if (phone && phone.id) {\n                    phone.phoneNumber = phoneNumber;\n                    updatePhone(phone.id, phone, function (result: boolean) {\n                        if (result) {\n                            success(result);\n                        } else {\n                            error('Unable to update phone');\n                        }\n                    }, function (reason: any) {\n                        error(reason);\n                    });\n                } else {\n                    error('No phone found');\n                }\n            },\n            function (reason: any) {\n                error(reason);\n            });\n        } else {\n            error('No user found');\n        }\n    }, function (reason: any) {\n        error(reason);\n    });\n}",
            "title": "Callbacks"
        },
        {
            "location": "/0-Overview/0.7-Asynchronous-Execution/#promises",
            "text": "Let's take a look at the Promise style code.  Here, each asynchronous function returns a  Promise  object, instead of taking in callback parameters.  This Promise provides access to the result of  exactly one  execution of the nested function.  Callbacks that execute many times, such as  window.setInterval ,  Array.prototype.forEach ,  Array.prototype.map , etc., are used different from Promises.  function editUserPhone(id: string, phoneNumber: string) {\n    return getUser(id).then(function (user) {\n        if (!user || !user.id) {\n            throw 'No user found';\n        }\n\n        return getPhone(user.id).then(function (phone) {\n            if (!phone || !phone.id) {\n                throw 'No phone found';\n            }\n\n            phone.phoneNumber = phoneNumber;\n            return updatePhone(phone.id, phone).then(function (result: boolean) {\n                if (!result) {\n                    throw 'Unable to update phone';\n                }\n\n                return result;\n            });\n        });\n    });\n}",
            "title": "Promises"
        },
        {
            "location": "/0-Overview/0.7-Asynchronous-Execution/#asyncawait",
            "text": "Let's now take a look at the  async  and  await  symbols.  If we mark a function as  async , it implicitly returns a  Promise  object.  This return type can be autogenerated by TypeScript, so a function that returns a  boolean  is now  Promise<boolean> .  Once we have marked it as  async , we gain access to the  await  symbol.  We simply use  await  before executing any function that returns a  Promise .  Instead of having to write  .then(function (result) { }) , the result will be turned to the left of the statement.  We can now write  let result = await getValue(); , and  result  will be populated with the data return from the asynchronous call.  async function editUserPhone(id: string, phoneNumber: string) {\n    let user = await getUser(id);\n    if (!user || !user.id) {\n        throw 'No user found';\n    }\n\n    let phone = await getPhone(user.id);\n    if (!phone || !phone.id) {\n        throw 'No phone found';\n    }\n\n    phone.phoneNumber = phoneNumber;\n    let result = await updatePhone(phone.id, phone);\n    if (!result) {\n        throw 'Unable to update phone';\n    }\n\n    return result;\n}",
            "title": "Async/Await"
        },
        {
            "location": "/1-Using-Recoil/1.0-Installing-Recoil/",
            "text": "In order to unify our UI/UX designs, it is best to use a standard style and component library.  For our purposes, we will look at Recoil.\n\n\nIn order to install Recoil, we must configure our project to compile \n.less\n files.  LESS is a dynamic language for generating stylesheets, and it is heavily used by Recoil to define its styles.\n\n\nIn the console, run\n\n\nnpm install css-loader less less-loader style-loader --save-dev\n\n\n\nThen, we must update our \nwebpack.config.js\n files.  If you're using the \nts-boilerplate\n project, be sure to update both versions of the configuration.  In the \nloaders\n array, add\n\n\n{\n    test: /\\.less$/,\n    loader: 'style-loader!css-loader!less-loader'\n}\n\n\n\n\nWe must now add Recoil.  In the console, run\n\n\nnpm install @cubex/recoil\n\n\n\nNow that we have recoil installed, we must reference the \n.less\n files.  In our \nmain.tsx\n, include the line\n\n\nimport '@cubex/recoil/less/index.less';\n\n\n\n\nThis directly references the stylesheet to be compiled by Webpack.  Furthermore, we only need to reference the stylesheet here.\n\n\nUsing Recoil in a View\n\n\nWe can now import Recoil components, which will be styled correctly.  For example, let's say we wish to use a \nButton\n in our component.  We can simply include\n\n\nimport { Button } from '@cubex/recoil';\n\n\n\n\nAnd then in the body of the component, we can use it directly\n\n\nrender() {\n    return (\n        <Button>OK</Button>\n    );\n}",
            "title": "Installing Recoil"
        },
        {
            "location": "/1-Using-Recoil/1.0-Installing-Recoil/#using-recoil-in-a-view",
            "text": "We can now import Recoil components, which will be styled correctly.  For example, let's say we wish to use a  Button  in our component.  We can simply include  import { Button } from '@cubex/recoil';  And then in the body of the component, we can use it directly  render() {\n    return (\n        <Button>OK</Button>\n    );\n}",
            "title": "Using Recoil in a View"
        },
        {
            "location": "/1-Using-Recoil/1.1-Using-Recoil-Docs/",
            "text": "Recoil contains many components which work together dynamically.  In order to get the most out of it, consider using its documentation directly.\n\n\nTo build Recoil's documentation, clone it from GitHub.\n\n\ngit clone https://github.com/Cubex30/recoil.git\n\n\n\nThen install the npm dependencies\n\n\nnpm install\n\n\n\nThen build the project\n\n\nnpm run build\n\n\n\nThen launch the documentation in your browser.  It should be located at \nrecoil/docs/index.html\n.",
            "title": "Using Recoil Docs"
        },
        {
            "location": "/1-Using-Recoil/1.2-Simple-Recoil-Projects/",
            "text": "To start our Recoil project, we need to import the \nRecoil\n Component.  This must be included in the root of any project.\n\n\nimport { Recoil } from '@cubex/recoil';\n\n\n\n\nNext, let's create our \nRoot\n Component.\n\n\nexport interface IRootProps {\n\n}\n\nexport default class Root extends React.Component<IRootProps, any> {\n    render () {\n        return (\n            <Recoil>\n            </Recoil>\n        );\n    }\n}",
            "title": "Simple Recoil Projects"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/",
            "text": "In order to develop our Single Page Application, we need to create a back-end service.  For consistency, we're going to use a Node.js server with \nsierra\n, an MVC framework.\n\n\nLet's create a new project for our service.\n\n\nFirst, we need to ensure Yeoman is installed\n\n\nnpm install -g yo\n\n\n\nThen we need to install our Yeoman generator for TypeScript\n\n\nnpm install -g generator-typescript-project\n\n\n\nNow we are ready to create our new project.  In our projects folder, we will create a directory \nexample-service\n.\n\n\nmkdir example-service\n\n\n\nEnter the new directory\n\n\ncd example-service\n\n\n\nNow let's run our generator, and answer any prompts.\n\n\nyo typescript-project\n\n\n\nPreparing our Project\n\n\nLet's install our dependencies.  First, we need to install \nsierra\n.\n\n\nnpm install sierra\n\n\n\nOpen \nsrc/tests/test.ts\n and remove any content.\n\n\nOpen \ntsconfig.json\n and change \ncompilerOptions.target\n to \nes2017\n.\n\n\nCreating a Sierra Server\n\n\nThen open \nsrc/scripts/main.ts\n.  Remove any content, add the following lines.\n\n\nimport Sierra from 'sierra';\n\nlet sierra = new Sierra();\n\nsierra.init();\nsierra.listen(8001);\n\n\n\n\nNote that we have imported \nsierra\n.  Then we created a Sierra instance, initialized it, and started listening on port 8001.\n\n\nLet's go ahead and run the following in the command prompt.\n\n\ntsc\nnpm run node\n\n\n\nOpen your browser, and navigate to \nhttp://localhost:8001\n.  You should see the message \n\"no route found\"\n.\n\n\nThis means that Sierra is running correctly, but we haven't yet configured it to do anything.\n\n\nMiddleware\n\n\nSierra works by running a series of \"Middleware\", which are simply a set of functions which are run in order, every time a Request is received by the server.  Middleware handle common tasks like retrieving Session information, parsing Post Body data, checking Authentication, etc.  Each Middleware returns a \nPromise\n, which allows them to pause execution in case of Database calls and the like.  If any unhandled exceptions occur, they are handled by the Error Middleware.  Once all of the Middleware have run, execution is sent to the \"Router\" which parses the URL, and runs a specified function.\n\n\nLet's take a look at how this all works.\n\n\nIn your \nsrc/scripts/main.ts\n, update the import line to:\n\n\nimport Sierra, { BodyMiddleware } from 'sierra';\n\n\n\n\nThis brings in the \nBodyMiddleware\n.  Now let's add it to our Middleware stack.\n\n\nAfter \nlet sierra = new Sierra();\n add the line\n\n\nsierra.use(BodyMiddleware.handle);\n\n\n\n\nThis will cause our \nBodyMiddleware\n to check for any Post Body data, and assemble it for use.\n\n\nRouting\n\n\nIf you build and run our server again, you'll see it still doesn't do anything.  We need to set up routes.\n\n\nCreate a file \nsrc/scripts/controllers/HomeController.ts\n.\n\n\nInside the file, add the lines:\n\n\nimport { Controller, method } from 'sierra';\n\nexport default class HomeController extends Controller {\n\n    constructor() {\n        super('/');\n    }\n\n    @method('get')\n    async index() {\n        return 'Home/index';\n    }\n}\n\n\n\n\nNote that we extend \nController\n, which provides a basic container for routes.  In the constructor, we set the base of our route to \n'/'\n, which means it will be our default Controller.  We'll take a look at auto-generated route names later.\n\n\nThen we created a \"Controller method\" called \nindex\n by adding the \n@method\n decorator and passing \n'get'\n.  This means our route will only respond to the \nGET\n HTTP method.\n\n\nWe also named the method \nindex\n which is a reserved method name.  It means this is the default method, and since we are already using the default controller, it means this method will run if we run the default URL.  Hence, we have just created a method for \nhttp://localhost:8001\n.\n\n\nNow, let's add our controller to Sierra.\n\n\nOpen \nsrc/scripts/main.ts\n and import our \nHomeController\n:\n\n\nimport HomeController from './controllers/HomeController';\n\n\n\n\nNow, before the init call, add \nHomeController\n to sierra:\n\n\nsierra.addController(new HomeController());\n\n\n\n\nBuild and run our server, and again navigate to \nhttp://localhost:8001\n.  You should see the message \n\"Home/index\"\n.\n\n\nGateway\n\n\nBefore we can build a full RESTful API, we need some data to serve.  For simplicity, we're going to use a local, JavaScript only database.  For a production server, this database would likely be insufficient, but it will work great for our purposes.\n\n\nGo to the command prompt, and install \nnedb\n.\n\n\nnpm install nedb\n\n\n\nCreate the file \nsrc/scripts/Gateway.ts\n and paste the following lines:\n\n\nimport * as Nedb from 'nedb';\n\nexport interface IModifier {\n    $set: any;\n    $unset: any;\n    $inc: any;\n    $min: any;\n    $max: any;\n    $push: any;\n    $pop: any;\n    $addToSet: any;\n    $pull: any;\n    $each: any;\n    $slice: any;\n}\n\nexport interface IQuery<T> {\n    $lt: T;\n    $lte: T;\n    $gt: T;\n    $gte: T;\n    $in: T;\n    $nin: T;\n    $ne: T;\n    $exists: T;\n    $regex: RegExp;\n}\n\nexport interface IDoc {\n    _id: string;\n}\n\nexport default class Gateway<T> {\n    db: Nedb;\n\n    constructor(file?: string) {\n        this.db = new Nedb({\n            filename: file,\n            autoload: true\n        });\n    }\n\n    create(doc: T): Promise<T & IDoc> {\n        return new Promise((resolve, reject) => {\n            this.db.insert(doc, function (err, newDoc) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(newDoc as any);\n                }\n            });\n        });\n    }\n\n    get(_id: string): Promise<T & IDoc> {\n        return new Promise((resolve, reject) => {\n            this.db.findOne({ _id: _id }, function (err, doc) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(doc as any);\n                }\n            });\n        });\n    }\n\n    update(_id: string, doc: T | IModifier): Promise<T & IDoc> {\n        return new Promise((resolve, reject) => {\n            this.db.update({ _id: _id }, doc, {}, function (err, docs) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(docs[0]);\n                }\n            });\n        });\n    }\n\n    find(query: Partial<T> | keyof T): Promise<(T & IDoc)[]> {\n        return new Promise((resolve, reject) => {\n            this.db.find(query, function (err, docs) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(docs);\n                }\n            });\n        })\n    };\n\n    delete(_id: string): Promise<number> {\n        return new Promise((resolve, reject) => {\n            this.db.remove({ _id: _id }, {}, function (err, numRemoved) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(numRemoved);\n                }\n            });\n        });\n    }\n}\n\n\n\n\nThis will create a Gateway for accessing our database.\n\n\nNow create a folder \ndata\n in the root of your project.  This will be used for storing our database.  If you need to reset any of the data, simply delete the files in this directory.  Also, if you decide to store your project in source control, do not commit this directory.\n\n\nService\n\n\nNow that we have a database, let's create our service to access the data.\n\n\nWe are going to create a list of Products that a user can manage.  They will have a \nname\n and a \ndescription\n.\n\n\nCreate a file \nsrc/scripts/data/IProduct.ts\n, and paste the following lines:\n\n\nexport interface IProduct {\n    name: string;\n    description: string;\n}\n\n\n\n\nThis interface will define the fields of our Product.\n\n\nNow create a file \nsrc/scripts/controllers/ProductController.ts\n, and paste the following lines:\n\n\nimport { Controller, method } from 'sierra';\n\nimport Gateway from './Gateway';\n\nimport { IProduct } from '../data/IProduct';\n\nexport default class ProductController extends Controller {\n    productGateway: Gateway<IProduct> = new Gateway<Test>('data/products.db');\n}\n\n\n\n\nNote that we have created a Controller called \nProductController\n.  We also imported both \nIProduct\n and \nGateway\n to create a gateway property.  Our Gateway instance points at a file \ndata/products.db\n which will store our data.\n\n\nAlso note that we didn't specify a base route.  Sierra will then generate a route automatically based on the Controller's name.  In this case, the base will be set to \nproduct\n.\n\n\nNow let's create our Controller methods.  We are creating a RESTful API, which in general conform to certain standards.  We want to support five operations: List, which will give us all records, and our \"CRUD\" operations:  Create, Read, Update, Delete.\n\n\n\n\nList\n - Uses the \nGET\n HTTP method, and is the default route \n/product\n.\n\n\nCreate\n - Uses the \nPOST\n HTTP method, and is the default route \n/product\n.\n\n\nRead\n - Uses the \nGET\n HTTP method, and is the route with an \nid\n parameter, \n/product/:id\n.\n\n\nUpdate\n - Uses the \nPUT\n HTTP method, and is the route with an \nid\n parameter, \n/product/:id\n.\n\n\nDelete\n - Uses the \nDELETE\n HTTP method, and is the route with an \nid\n parameter, \n/product/:id\n.\n\n\n\n\nLet's create the \nList\n method.  Inside the class, add the following lines:\n\n\n@method('get')\nasync index() {\n    return await this.gateway.find({});\n}\n\n\n\n\nHere we have created another \nindex\n method, but in this case we are returning the results of \nthis.gateway.find({})\n, which will return all rows of our products.\n\n\nNow let's create the \nCreate\n method.  Inside the class, add the following lines:\n\n\n@method('post')\nasync post($body: IProduct) {\n    return this.gateway.create($body);\n}\n\n\n\n\nHere we again used another reserved method name, \npost\n.  If we use a reserved method name that matches the HTTP method, we will use the default route.  Then we used a \"special parameter\" \n$body\n, which is provided by Sierra to represent the Post Body data.  We then store the \n$body\n with \nthis.gateway.create($body)\n.\n\n\nFor our next three methods, we are going to use \"query parameters\".  These are named portions of the URL pathname which are parsed and passed as parameters.\n\n\n@method('get', '/:id')\nasync get(id: string) {\n    return await this.gateway.get(id);\n}\n\n\n\n\nHere we defined our route as \n/:id\n, which is appended onto the \nproduct\n base route.  It is then automatically passed as the \nid\n parameter.  These parameters are all type \nstring\n.  We then pass the \nid\n to \nthis.gateway.get(id)\n.\n\n\nFor our remaining methods, we use similar ideas.\n\n\n@method('put', '/:id')\nasync put(id: string, $body: IProduct) {\n    return this.gateway.update(id, $body);\n}\n\n@method('delete', '/:id')\nasync delete(id: string) {\n    return this.gateway.delete(id);\n}\n\n\n\n\nTesting\n\n\nIn order to test our service, we will need a better tool than a browser.  Download \nPostman\n from \nhttps://www.getpostman.com/\n.",
            "title": "Example Back End"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#preparing-our-project",
            "text": "Let's install our dependencies.  First, we need to install  sierra .  npm install sierra  Open  src/tests/test.ts  and remove any content.  Open  tsconfig.json  and change  compilerOptions.target  to  es2017 .",
            "title": "Preparing our Project"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#creating-a-sierra-server",
            "text": "Then open  src/scripts/main.ts .  Remove any content, add the following lines.  import Sierra from 'sierra';\n\nlet sierra = new Sierra();\n\nsierra.init();\nsierra.listen(8001);  Note that we have imported  sierra .  Then we created a Sierra instance, initialized it, and started listening on port 8001.  Let's go ahead and run the following in the command prompt.  tsc\nnpm run node  Open your browser, and navigate to  http://localhost:8001 .  You should see the message  \"no route found\" .  This means that Sierra is running correctly, but we haven't yet configured it to do anything.",
            "title": "Creating a Sierra Server"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#middleware",
            "text": "Sierra works by running a series of \"Middleware\", which are simply a set of functions which are run in order, every time a Request is received by the server.  Middleware handle common tasks like retrieving Session information, parsing Post Body data, checking Authentication, etc.  Each Middleware returns a  Promise , which allows them to pause execution in case of Database calls and the like.  If any unhandled exceptions occur, they are handled by the Error Middleware.  Once all of the Middleware have run, execution is sent to the \"Router\" which parses the URL, and runs a specified function.  Let's take a look at how this all works.  In your  src/scripts/main.ts , update the import line to:  import Sierra, { BodyMiddleware } from 'sierra';  This brings in the  BodyMiddleware .  Now let's add it to our Middleware stack.  After  let sierra = new Sierra();  add the line  sierra.use(BodyMiddleware.handle);  This will cause our  BodyMiddleware  to check for any Post Body data, and assemble it for use.",
            "title": "Middleware"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#routing",
            "text": "If you build and run our server again, you'll see it still doesn't do anything.  We need to set up routes.  Create a file  src/scripts/controllers/HomeController.ts .  Inside the file, add the lines:  import { Controller, method } from 'sierra';\n\nexport default class HomeController extends Controller {\n\n    constructor() {\n        super('/');\n    }\n\n    @method('get')\n    async index() {\n        return 'Home/index';\n    }\n}  Note that we extend  Controller , which provides a basic container for routes.  In the constructor, we set the base of our route to  '/' , which means it will be our default Controller.  We'll take a look at auto-generated route names later.  Then we created a \"Controller method\" called  index  by adding the  @method  decorator and passing  'get' .  This means our route will only respond to the  GET  HTTP method.  We also named the method  index  which is a reserved method name.  It means this is the default method, and since we are already using the default controller, it means this method will run if we run the default URL.  Hence, we have just created a method for  http://localhost:8001 .  Now, let's add our controller to Sierra.  Open  src/scripts/main.ts  and import our  HomeController :  import HomeController from './controllers/HomeController';  Now, before the init call, add  HomeController  to sierra:  sierra.addController(new HomeController());  Build and run our server, and again navigate to  http://localhost:8001 .  You should see the message  \"Home/index\" .",
            "title": "Routing"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#gateway",
            "text": "Before we can build a full RESTful API, we need some data to serve.  For simplicity, we're going to use a local, JavaScript only database.  For a production server, this database would likely be insufficient, but it will work great for our purposes.  Go to the command prompt, and install  nedb .  npm install nedb  Create the file  src/scripts/Gateway.ts  and paste the following lines:  import * as Nedb from 'nedb';\n\nexport interface IModifier {\n    $set: any;\n    $unset: any;\n    $inc: any;\n    $min: any;\n    $max: any;\n    $push: any;\n    $pop: any;\n    $addToSet: any;\n    $pull: any;\n    $each: any;\n    $slice: any;\n}\n\nexport interface IQuery<T> {\n    $lt: T;\n    $lte: T;\n    $gt: T;\n    $gte: T;\n    $in: T;\n    $nin: T;\n    $ne: T;\n    $exists: T;\n    $regex: RegExp;\n}\n\nexport interface IDoc {\n    _id: string;\n}\n\nexport default class Gateway<T> {\n    db: Nedb;\n\n    constructor(file?: string) {\n        this.db = new Nedb({\n            filename: file,\n            autoload: true\n        });\n    }\n\n    create(doc: T): Promise<T & IDoc> {\n        return new Promise((resolve, reject) => {\n            this.db.insert(doc, function (err, newDoc) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(newDoc as any);\n                }\n            });\n        });\n    }\n\n    get(_id: string): Promise<T & IDoc> {\n        return new Promise((resolve, reject) => {\n            this.db.findOne({ _id: _id }, function (err, doc) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(doc as any);\n                }\n            });\n        });\n    }\n\n    update(_id: string, doc: T | IModifier): Promise<T & IDoc> {\n        return new Promise((resolve, reject) => {\n            this.db.update({ _id: _id }, doc, {}, function (err, docs) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(docs[0]);\n                }\n            });\n        });\n    }\n\n    find(query: Partial<T> | keyof T): Promise<(T & IDoc)[]> {\n        return new Promise((resolve, reject) => {\n            this.db.find(query, function (err, docs) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(docs);\n                }\n            });\n        })\n    };\n\n    delete(_id: string): Promise<number> {\n        return new Promise((resolve, reject) => {\n            this.db.remove({ _id: _id }, {}, function (err, numRemoved) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(numRemoved);\n                }\n            });\n        });\n    }\n}  This will create a Gateway for accessing our database.  Now create a folder  data  in the root of your project.  This will be used for storing our database.  If you need to reset any of the data, simply delete the files in this directory.  Also, if you decide to store your project in source control, do not commit this directory.",
            "title": "Gateway"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#service",
            "text": "Now that we have a database, let's create our service to access the data.  We are going to create a list of Products that a user can manage.  They will have a  name  and a  description .  Create a file  src/scripts/data/IProduct.ts , and paste the following lines:  export interface IProduct {\n    name: string;\n    description: string;\n}  This interface will define the fields of our Product.  Now create a file  src/scripts/controllers/ProductController.ts , and paste the following lines:  import { Controller, method } from 'sierra';\n\nimport Gateway from './Gateway';\n\nimport { IProduct } from '../data/IProduct';\n\nexport default class ProductController extends Controller {\n    productGateway: Gateway<IProduct> = new Gateway<Test>('data/products.db');\n}  Note that we have created a Controller called  ProductController .  We also imported both  IProduct  and  Gateway  to create a gateway property.  Our Gateway instance points at a file  data/products.db  which will store our data.  Also note that we didn't specify a base route.  Sierra will then generate a route automatically based on the Controller's name.  In this case, the base will be set to  product .  Now let's create our Controller methods.  We are creating a RESTful API, which in general conform to certain standards.  We want to support five operations: List, which will give us all records, and our \"CRUD\" operations:  Create, Read, Update, Delete.   List  - Uses the  GET  HTTP method, and is the default route  /product .  Create  - Uses the  POST  HTTP method, and is the default route  /product .  Read  - Uses the  GET  HTTP method, and is the route with an  id  parameter,  /product/:id .  Update  - Uses the  PUT  HTTP method, and is the route with an  id  parameter,  /product/:id .  Delete  - Uses the  DELETE  HTTP method, and is the route with an  id  parameter,  /product/:id .   Let's create the  List  method.  Inside the class, add the following lines:  @method('get')\nasync index() {\n    return await this.gateway.find({});\n}  Here we have created another  index  method, but in this case we are returning the results of  this.gateway.find({}) , which will return all rows of our products.  Now let's create the  Create  method.  Inside the class, add the following lines:  @method('post')\nasync post($body: IProduct) {\n    return this.gateway.create($body);\n}  Here we again used another reserved method name,  post .  If we use a reserved method name that matches the HTTP method, we will use the default route.  Then we used a \"special parameter\"  $body , which is provided by Sierra to represent the Post Body data.  We then store the  $body  with  this.gateway.create($body) .  For our next three methods, we are going to use \"query parameters\".  These are named portions of the URL pathname which are parsed and passed as parameters.  @method('get', '/:id')\nasync get(id: string) {\n    return await this.gateway.get(id);\n}  Here we defined our route as  /:id , which is appended onto the  product  base route.  It is then automatically passed as the  id  parameter.  These parameters are all type  string .  We then pass the  id  to  this.gateway.get(id) .  For our remaining methods, we use similar ideas.  @method('put', '/:id')\nasync put(id: string, $body: IProduct) {\n    return this.gateway.update(id, $body);\n}\n\n@method('delete', '/:id')\nasync delete(id: string) {\n    return this.gateway.delete(id);\n}",
            "title": "Service"
        },
        {
            "location": "/2-Using-Application-State/2.0-Example-Back-End/#testing",
            "text": "In order to test our service, we will need a better tool than a browser.  Download  Postman  from  https://www.getpostman.com/ .",
            "title": "Testing"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/",
            "text": "Data\n\n\nConnections\n\n\nModels\n\n\nStores\n\n\nManagers\n\n\nWorkflows\n\n\nStates\n\n\nRoutes",
            "title": "State Organization"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#data",
            "text": "",
            "title": "Data"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#connections",
            "text": "",
            "title": "Connections"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#stores",
            "text": "",
            "title": "Stores"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#managers",
            "text": "",
            "title": "Managers"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#workflows",
            "text": "",
            "title": "Workflows"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#states",
            "text": "",
            "title": "States"
        },
        {
            "location": "/2-Using-Application-State/2.1-State-Organization/#routes",
            "text": "",
            "title": "Routes"
        },
        {
            "location": "/2-Using-Application-State/2.2-Connections/",
            "text": "",
            "title": "Connections"
        },
        {
            "location": "/2-Using-Application-State/2.3-Models-and-Stores/",
            "text": "",
            "title": "Models and Stores"
        },
        {
            "location": "/2-Using-Application-State/2.4-Managers/",
            "text": "",
            "title": "Managers"
        },
        {
            "location": "/2-Using-Application-State/2.5-Workflows/",
            "text": "",
            "title": "Workflows"
        },
        {
            "location": "/2-Using-Application-State/2.6-Routing/",
            "text": "Browser history is commonly accessed through two ways, the History API, and URL hashes.\n\n\nnpm install @cubex/router",
            "title": "Routing"
        }
    ]
}