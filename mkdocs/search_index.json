{
    "docs": [
        {
            "location": "/",
            "text": "Cubex User Interface Tutorial",
            "title": "Home"
        },
        {
            "location": "/#cubex-user-interface-tutorial",
            "text": "",
            "title": "Cubex User Interface Tutorial"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/",
            "text": "Setting up your development environment can be done in just a few steps.\n\n\nInstalling TypeScript\n\n\nFor simplicity in these tutorials, you can download a boilerplate at \nhttps://github.com/sjohnsonaz/ts-boilerplate\n.  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.\n\n\nUsing npm\n\n\nFor TypeScript, the simplest way to install packages is through npm.  Any project using npm must define a \npackage.json\n file in its root directory.  The boilerplate above already has done this for you.  This file defines useful information about your project.  For simply developing a project, the most important sections are for defining its dependencies. However, if you were to publish your project to npm so others could use it, this file includes other important information which would need customizing.\n\n\nThe \npackage.json\n file defines several properties to store dependencies:\n\n\n\n\n\"dependencies\"\n\n\n\"devDependencies\"\n\n\n\"peerDependencies\"\n\n\n\"bundledDependencies\"\n\n\n\"optionalDependencies\"\n\n\n\n\nFor our purposes, we will be most concerned with the first two.  By default, packages are installed as \"dependencies\", which means any time your project is installed, these will be installed along with it.  However, in some cases your project may need certain packages while it is being developed, but not while it is being used.  For example, we might install TypeScript on the development environment to build our project, but we certainly don't need to deploy it along with the project.  In this case, these packages should be installed as \"devDependencies\".\n\n\nFor more information, refer to \npackage.json | npm Documentation\n.\n\n\nInstalling React and MobX\n\n\nWe need to install four packages as regular dependencies.\n\n\n\n\nreact\n\n\nreact-dom\n\n\nmobx\n\n\nmobx-react\n\n\n\n\nThis is done with a simple \nnpm install\n command:\n\n\nnpm install react react-dom mobx mobx-react\n\n\n\nIn older versions of npm, we would need to append \n--save\n to the end of that command.\n\n\nKeep in mind, any dependency to be saved to \"devDependencies\" should be installed with \n--save-dev\n appended.",
            "title": "Getting Started"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#installing-typescript",
            "text": "For simplicity in these tutorials, you can download a boilerplate at  https://github.com/sjohnsonaz/ts-boilerplate .  Follow its instructions to get a TypeScript environment up and running.  Otherwise, you will need to set up Node, TypeScript, and Webpack to compile and run these projects.",
            "title": "Installing TypeScript"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#using-npm",
            "text": "For TypeScript, the simplest way to install packages is through npm.  Any project using npm must define a  package.json  file in its root directory.  The boilerplate above already has done this for you.  This file defines useful information about your project.  For simply developing a project, the most important sections are for defining its dependencies. However, if you were to publish your project to npm so others could use it, this file includes other important information which would need customizing.  The  package.json  file defines several properties to store dependencies:   \"dependencies\"  \"devDependencies\"  \"peerDependencies\"  \"bundledDependencies\"  \"optionalDependencies\"   For our purposes, we will be most concerned with the first two.  By default, packages are installed as \"dependencies\", which means any time your project is installed, these will be installed along with it.  However, in some cases your project may need certain packages while it is being developed, but not while it is being used.  For example, we might install TypeScript on the development environment to build our project, but we certainly don't need to deploy it along with the project.  In this case, these packages should be installed as \"devDependencies\".  For more information, refer to  package.json | npm Documentation .",
            "title": "Using npm"
        },
        {
            "location": "/0-Overview/0.0-Getting-Started/#installing-react-and-mobx",
            "text": "We need to install four packages as regular dependencies.   react  react-dom  mobx  mobx-react   This is done with a simple  npm install  command:  npm install react react-dom mobx mobx-react  In older versions of npm, we would need to append  --save  to the end of that command.  Keep in mind, any dependency to be saved to \"devDependencies\" should be installed with  --save-dev  appended.",
            "title": "Installing React and MobX"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/",
            "text": "In this tutorial, we take a look at React and MobX, what they can do, and the fundamental parts of any React and MobX project.  You should already have a TypeScript environment running, and have included the necessary packages in your project dependencies.\n\n\nProject Organization\n\n\nAny React and MobX project includes \nApplication State\n and \nComponents\n.  This is similar to many common patterns such as \nMVC\n or \nMVVM\n, where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.\n\n\nBefore we get started, your TypeScript project should have a \ntsconfig.json\n file.  Open this file, and ensure the following options are set:\n\n\n\"jsx\": \"react\",\n\"experimentalDecorators\": true\n\n\n\n\nAlso, ensure that you have \nsrc\n and \npublic\n directories in your project.\n\n\nBuilding your Project\n\n\nIt will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.\n\n\nInside the \npublic\n directory, create a file \nindex.html\n.  This will be the main HTML file that runs the project.\n\n\n<!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>\n\n\n\n\nThis file creates a \n<div>\n to mount our component, and then loads the script.  Note that we're loading our script from \nbundle/main.js\n, which is a file that doesn't currently exist.  We are going to build it later.\n\n\nInside the \nsrc/scripts\n directory, create a file \nmain.tsx\n.\n\n\nwindow.onload = function () {\n    console.log('started');\n}\n\n\n\n\nWe now must set up Webpack to build our \nmain.tsx\n file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the \nentry\n and \noutput\n objects have the correct values.  it should read:\n\n\n    entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },\n\n\n\n\nThis is likely very similar to what is already there.  Simply change \nmain.ts\n to \nmain.tsx\n, the filename from \ndist\n to \npublic\n, and remove the \n.min\n portion of the filename.\n\n\nNow to test it, run\n\n\nnpm run dev\n\n\n\nIf you want to run automatically as you're developing, call\n\n\nnpm run watch\n\n\n\nIf you want to run a minified version of the file, call\n\n\nnpm run min\n\n\n\nIf it is successful, open the \npublic/index.html\n file in your browser.  Open the browser's console, and you should see \nstarted\n printed to the screen.\n\n\nApplication State\n\n\nMobX stores its data in \nApplication State\n objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.  \n\n\nLet's say we want to create a \nModel\n of a \nUser\n.  It should store common information for our users, like first and last name.  We also will want to edit it.\n\n\nSo, we start by declaring a class, and adding several properties.  Inside your project, create a folder \nsrc/scripts/models\n, and inside it a file \nUser.ts\n.\n\n\nexport default class User {\n    firstName: string;\n    lastName: string;\n}\n\n\n\n\nFantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.\n\n\nComponents\n\n\nReact displays its data in \nComponents\n, which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.\n\n\nSo, since we have our User model, let's display it!  Inside your project, create a folder \nsrc/scripts/views/user\n, and inside it a file \nUserView.tsx\n.\n\n\nFirst, we must import React into the file.\n\n\nimport * as React from 'react';\n\n\n\n\nWe have imported React, which contains the Component class.  While we will not necessarily use the \nReact\n import directly in our code, the JSX interpreter will transpile our JSX statements into React calls.  This process turns what appear to be XML elements into:\n\n\nReact.createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P,\n        ...children: ReactNode[]): DOMElement<P, T>;\n\n\n\n\nNow we must import our User model.\n\n\nimport User from '../../models/User';\n\n\n\n\nWe now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.\n\n\nexport interface IUserViewProps {\n    user: User;\n}\n\n\n\n\nNext we need to define our component itself.\n\n\nexport default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThis component takes in a user, and displays the \nfirstName\n and \nlastName\n inside to \n<p>\n elements, wrapped inside one \n<div>\n element.\n\n\nThere are a couple things to note:\n\n\n\n\nWe used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.\n\n\nWe used object destructuring to get \nuser\n from \nthis.props\n.  This is a shorthand that is much simpler than \nlet user = this.props.user;\n.  It especially comes in handy if you're doing that for multiple properties.\n\n\nEvery component must define a render method, even if it returns nothing.\n\n\nA component may return exactly one value.  Here we wrapped our multiple \n<p>\n tags in a single \n<div>\n tag.\n\n\nWe user the \n{}\n notation to insert the \nuser\n values into the elements.\n\n\n\n\nRendering\n\n\nWe now must render our \nApplication State\n into \nComponent\n and display it to the DOM.\n\n\nInside the \nmain.tsx\n we must import all of our files, and then render them.\n\n\nimport * as ReactDom from 'react-dom'\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    ReactDom.render(\n        document.getElementById('root'),\n        <UserView user={User} />\n    );\n};\n\n\n\n\nThere are a couple things to note:\n\n\n\n\nWe imported ReactDom, our \nUser\n, and our \nUserView\n.\n\n\nWe write our code inside the onload function to ensure it runs after everything is ready.\n\n\nWe create a new user and set the first and last name properties.\n\n\nWe get the \nroot\n element from the DOM\n\n\nWe create a new \nUserView\n with JSX, pass in the user.\n\n\nWe pass the \nroot\n element and the \nUserView\n to \nReactDom.render()\n.\n\n\n\n\nNow build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Displaying Data"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#project-organization",
            "text": "Any React and MobX project includes  Application State  and  Components .  This is similar to many common patterns such as  MVC  or  MVVM , where you have a distinct separation between your data, and how you display it.  Ultimately, the specifics of your pattern are up to you, but the overal concept is the same.  We will introduce some common patterns in later tutorials.  Before we get started, your TypeScript project should have a  tsconfig.json  file.  Open this file, and ensure the following options are set:  \"jsx\": \"react\",\n\"experimentalDecorators\": true  Also, ensure that you have  src  and  public  directories in your project.",
            "title": "Project Organization"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#building-your-project",
            "text": "It will be easier to develop our project if we can run it.  Let's start by setting up a simple set of files and getting the to build.  Inside the  public  directory, create a file  index.html .  This will be the main HTML file that runs the project.  <!DOCTYPE>\n<html>\n\n<head>\n    <title>Tutorial 0</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n    <script src=\"bundle/main.js\" type=\"text/javascript\"></script>\n</body>\n\n</html>  This file creates a  <div>  to mount our component, and then loads the script.  Note that we're loading our script from  bundle/main.js , which is a file that doesn't currently exist.  We are going to build it later.  Inside the  src/scripts  directory, create a file  main.tsx .  window.onload = function () {\n    console.log('started');\n}  We now must set up Webpack to build our  main.tsx  file.  Inside the webpack configs (there are two if you're using the ts-boilerplate), ensure that the  entry  and  output  objects have the correct values.  it should read:      entry: {\n        'main': './src/scripts/main.tsx'\n    },\n    output: {\n        filename: './public/bundle/[name].js',\n        libraryTarget: 'var',\n        library: '[name]'\n    },  This is likely very similar to what is already there.  Simply change  main.ts  to  main.tsx , the filename from  dist  to  public , and remove the  .min  portion of the filename.  Now to test it, run  npm run dev  If you want to run automatically as you're developing, call  npm run watch  If you want to run a minified version of the file, call  npm run min  If it is successful, open the  public/index.html  file in your browser.  Open the browser's console, and you should see  started  printed to the screen.",
            "title": "Building your Project"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#application-state",
            "text": "MobX stores its data in  Application State  objects.  Depending on what you want to store, they may contain values, other objects, arrays, or even methods to manipulate the data.    Let's say we want to create a  Model  of a  User .  It should store common information for our users, like first and last name.  We also will want to edit it.  So, we start by declaring a class, and adding several properties.  Inside your project, create a folder  src/scripts/models , and inside it a file  User.ts .  export default class User {\n    firstName: string;\n    lastName: string;\n}  Fantastic!  We now have a User class which will correctly store our data!  We have also exported it as default from this file.",
            "title": "Application State"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#components",
            "text": "React displays its data in  Components , which are simply classes that render to the DOM.  They may render Nodes, strings, numbers, nothing, or even other Components.  So, since we have our User model, let's display it!  Inside your project, create a folder  src/scripts/views/user , and inside it a file  UserView.tsx .  First, we must import React into the file.  import * as React from 'react';  We have imported React, which contains the Component class.  While we will not necessarily use the  React  import directly in our code, the JSX interpreter will transpile our JSX statements into React calls.  This process turns what appear to be XML elements into:  React.createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P,\n        ...children: ReactNode[]): DOMElement<P, T>;  Now we must import our User model.  import User from '../../models/User';  We now must define what properties our component takes.  Our component will take in a user.  These appear as XML Attributes in our JSX code.  export interface IUserViewProps {\n    user: User;\n}  Next we need to define our component itself.  export default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n            </div>\n        );\n    }\n}  This component takes in a user, and displays the  firstName  and  lastName  inside to  <p>  elements, wrapped inside one  <div>  element.  There are a couple things to note:   We used the Props interface inside the Component definition.  This provides intellisense both when writing the component, and later when we use it.  We used object destructuring to get  user  from  this.props .  This is a shorthand that is much simpler than  let user = this.props.user; .  It especially comes in handy if you're doing that for multiple properties.  Every component must define a render method, even if it returns nothing.  A component may return exactly one value.  Here we wrapped our multiple  <p>  tags in a single  <div>  tag.  We user the  {}  notation to insert the  user  values into the elements.",
            "title": "Components"
        },
        {
            "location": "/0-Overview/0.1-Displaying-Data/#rendering",
            "text": "We now must render our  Application State  into  Component  and display it to the DOM.  Inside the  main.tsx  we must import all of our files, and then render them.  import * as ReactDom from 'react-dom'\n\nimport User from './models/User';\nimport UserView from './views/UserView';\n\nwindow.onload = function () {\n    var user = new User();\n    user.firstName = 'First';\n    user.lastName = 'Last';\n\n    ReactDom.render(\n        document.getElementById('root'),\n        <UserView user={User} />\n    );\n};  There are a couple things to note:   We imported ReactDom, our  User , and our  UserView .  We write our code inside the onload function to ensure it runs after everything is ready.  We create a new user and set the first and last name properties.  We get the  root  element from the DOM  We create a new  UserView  with JSX, pass in the user.  We pass the  root  element and the  UserView  to  ReactDom.render() .   Now build the project and run the HTML file in your browser.  It should display your user in the HTML you specified.",
            "title": "Rendering"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/",
            "text": "We've successfully created a working Application.  When we run it, data is presented to the browser as intended.  But what happens if we want to change the data?  Currently, if we change the model, nothing.  Lucky for you, React and MobX makes this simple.\n\n\nObservable Properties\n\n\nMobX provides \nObservable\n properties for objects.  Once established, these special properties may be \nsubscribed\n to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.\n\n\nWe can use the TypeScript decorator \n@observable\n in the class definition to make a property observable.\n\n\n@observable property: type = value;\n\n\n\n\nLet's take our \nUser\n example from the last chapter, and make it observable.  So, simply import the \n@observable\n decorator, and add it in front of any properties you want to observe.\n\n\nimport { observable } from 'mobx';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}\n\n\n\n\nAnd there we have it!  Our \nfirstName\n and \nlastName\n properties are now Observables!\n\n\nHandling Input\n\n\nNow that we can watch for changes in our data, let's set up some inputs!  \n\n\nimport * as React from 'react';\nimport { observer } from 'mobx-react';\n\nimport User from '../../models/User';\n\nexport interface IUserViewProps {\n    user: User;\n}\n\nexport default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nWe have included \nobserver\n decorator from \nmobx-react\n.\n\n\nWe have used the \n@observer\n in front of our \nUserView\n to allow it to detect changes to Observables.\n\n\nWe have included two \n<input>\n tags.\n\n\nWe inject the value using \n{}\n notation.\n\n\n\n\nWhen you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.\n\n\nReact works with \none way data binding\n, meaning that changes to data flow from \nApplication State\n to \nComponents\n not the other way around.  This is to prevent \ncircular references\n, where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.\n\n\nSo, any changes to our \nUser\n will show up in our \nUserView\n, but changes to our \nUserView\n don't automatically go back to our \nUser\n.  In order for that to happen, we need to handle \nEvents\n.\n\n\nAn \nEvent\n is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.\n\n\nFor our \nUserView\n add these two methods above the \nrender\n method.\n\n\nupdateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}\n\n\n\n\nThere are a couple of things to note:\n\n\n\n\nThese methods will handle the \nEvent\n, and store the value of the target into our \nUser\n.\n\n\nWe are using the \nArrow Function\n notation, as the \nthis\n value may be changed while executing.\n\n\n\n\nBut how do we hook these handlers up to our inputs?\n\n\n<p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName} /></p>\n\n\n\n\nAnd that's it!  Any time the user updates the text inputs, the \nEvent\n is triggered, and the \nUser\n is updated.\n\n\nWe could also use regular methods instead of Arrow Functions for \nupdateFirstName\n and \nupdateLastName\n.  In that case, when we inject them, we must use \nFunction.bind()\n.\n\n\n<p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName.bind(this)} /></p>\n\n\n\n\nIn many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method, \nFunction.bind(this, value)\n is useful.\n\n\nRunning our Application\n\n\nSo, we can now display and update our \nUser\n.  Try running it and see what happens!",
            "title": "Updating Data"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#observable-properties",
            "text": "MobX provides  Observable  properties for objects.  Once established, these special properties may be  subscribed  to.  Then, if the value of the property changes, the subscribers will be notified with the updated value.  These special properties can be read and written to exactly like regular properties.  We can use the TypeScript decorator  @observable  in the class definition to make a property observable.  @observable property: type = value;  Let's take our  User  example from the last chapter, and make it observable.  So, simply import the  @observable  decorator, and add it in front of any properties you want to observe.  import { observable } from 'mobx';\n\nexport default class User {\n    @observable firstName: string;\n    @observable lastName: string;\n}  And there we have it!  Our  firstName  and  lastName  properties are now Observables!",
            "title": "Observable Properties"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#handling-input",
            "text": "Now that we can watch for changes in our data, let's set up some inputs!    import * as React from 'react';\nimport { observer } from 'mobx-react';\n\nimport User from '../../models/User';\n\nexport interface IUserViewProps {\n    user: User;\n}\n\nexport default class UserView extends React.Component<IUserViewProps, any> {\n    render() {\n        let {user} = this.props;\n        return (\n            <div>\n                <p>First name: {user.firstName}</p>\n                <p>Last name: {user.lastName}</p>\n                <p>First name: <input type=\"text\" value={user.firstName} /></p>\n                <p>Last name: <input type=\"text\" value={user.lastName} /></p>\n            </div>\n        );\n    }\n}  There are a couple of things to note:   We have included  observer  decorator from  mobx-react .  We have used the  @observer  in front of our  UserView  to allow it to detect changes to Observables.  We have included two  <input>  tags.  We inject the value using  {}  notation.   When you run it, you will see your data now displayed in two text fields.  But what happens when you type in the inputs?  Currently, still nothing.  React works with  one way data binding , meaning that changes to data flow from  Application State  to  Components  not the other way around.  This is to prevent  circular references , where an update moves from A to B to C and so on, but somehow goes back to A.  If that happens, we will end up in an infinite loop.  So, any changes to our  User  will show up in our  UserView , but changes to our  UserView  don't automatically go back to our  User .  In order for that to happen, we need to handle  Events .  An  Event  is triggered when something happens, like when a user clicks the mouse, or presses a key.  It can even happen when an AJAX call completes.  Normally, a program will execute its instructions until there is nothing left to do, and it will either end, or wait for input.  So, we need to handle that input.  For our  UserView  add these two methods above the  render  method.  updateFirstName = (event) => {\n    this.props.user.firstName = event.target.value;\n}\n\nupdateLastName = (event) => {\n    this.props.user.lastName = event.target.value;\n}  There are a couple of things to note:   These methods will handle the  Event , and store the value of the target into our  User .  We are using the  Arrow Function  notation, as the  this  value may be changed while executing.   But how do we hook these handlers up to our inputs?  <p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName} /></p>  And that's it!  Any time the user updates the text inputs, the  Event  is triggered, and the  User  is updated.  We could also use regular methods instead of Arrow Functions for  updateFirstName  and  updateLastName .  In that case, when we inject them, we must use  Function.bind() .  <p>First name: <input type=\"text\" value={user.firstName} oninput={this.updateFirstName.bind(this)} /></p>\n<p>Last name: <input type=\"text\" value={user.lastName} oninput={this.updateLastName.bind(this)} /></p>  In many cases, this syntax is harder to read, but it is personal preference.  In some cases, where you must inject a specific value into the method,  Function.bind(this, value)  is useful.",
            "title": "Handling Input"
        },
        {
            "location": "/0-Overview/0.2-Updating-Data/#running-our-application",
            "text": "So, we can now display and update our  User .  Try running it and see what happens!",
            "title": "Running our Application"
        }
    ]
}